# React Compiler

<br />
<br />

* 더이상 최적화를 할 필요가 없어졌다.

---

```
React Compiler는 메모이제이션을 자동으로 처리하여,
수동으로 memoization을 처리할 필요가 없어졌다.
```

<br />
<br />
<br />
<br />

1. 리액트 컴파일러로 변경되는 것들 예시

```tsx
// 이러한 컴포넌트가 있다고 가정

const Component = () => {
  const onSubmit = () => {};
  const onMount = () => {};

  useEffect(() => {
    onMount();
  }, [onMount]);

  return <Form onSubmit={onSubmit} />;
};
```

```tsx
// 내부적으로 위 코드는 onSubmit과 onMount는 모두 useCallback으로 감싸지고 Form은 React.memo로 감싸진 것처럼 동작할 것

const FormMemo = React.memo(Form);

const Component = () => {
  const onSubmit = useCallback(() => {}, []);
  const onMount = useCallback(() => {}, []);

  useEffect(() => {
    onMount();
  }, [onMount]);

  return <FormMemo onSubmit={onSubmit} />;
};
```

```
물론 컴파일러가 정확히 이 코드로 변환하는 것은 아니며,
이보다 훨씬 더 복잡하고 발전된 형태일 것이다.
```

<br />
<br />
<br />

2. 여전히 애초에 리렌더링을 줄이는게 중요하다.

```
useCallback과 memo를 사용하기 전에
밑에 기법들을 사용하기를 권장한다.
```

```tsx
// 나쁜 예시

const Component = () => {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <>
      <Button onClick={() => setIsOpen(true)}>open dialog</Button>
      {isOpen && <ModalDialog />}
      <VerySlowComponent />
    </>
  );
};
```

```tsx
// 아무것도 메모이제이션하지 않고도 VerySlowComponent의 불필요한 리렌더링을 제거

const ButtonWithDialog = () => {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <>
      <Button onClick={() => setIsOpen(true)}>open dialog</Button>
      {isOpen && <ModalDialog />}
    </>
  );
};

const Component = () => {
  return (
    <>
      <ButtonWithDialog />
      <VerySlowComponent />
    </>
  );
};
```
