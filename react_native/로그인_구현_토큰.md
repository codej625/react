# React Native + Expo 에서 로그인을 구현하기

<br />
<br />

* 앱과 웹의 로그인 구현은 방식이 다르다.

```
앱에서는 쿠키를 사용하지 않기 때문에,
로그인 구현 방식이 다르다.

이 글에서는 보안을 위해 expo의 패키지를 사용한다.
```

<br />
<br />
<br />
<br />

1. 프로젝트 구조

```
src/
├── types/
│   ├── auth.types.ts          # 인증 관련 타입
│   ├── api.types.ts           # API 응답 타입
│   └── navigation.types.ts    # 네비게이션 타입
├── config/
│   └── env.ts                 # 환경 변수 관리
├── utils/
│   ├── storage.ts             # SecureStore 래퍼
│   └── error-handler.ts       # 에러 처리
├── stores/
│   └── authStore.ts           # Zustand 인증 스토어
├── services/
│   ├── api.ts                 # Axios 클라이언트
│   └── auth.service.ts        # 인증 서비스
├── schemas/
│   └── auth.schema.ts         # Zod 유효성 검사
├── hooks/
│   └── useAuth.ts             # 인증 커스텀 Hook
└── screens/
    ├── LoginScreen.tsx        # 로그인 화면 (예시)
    └── HomeScreen.tsx         # 홈 화면 (예시)
```

<br />
<br />
<br />

2. 패키지 설치

```bash
# 필수 패키지
npx expo install expo-secure-store
npx expo install expo-constants

npm install zustand
npm install axios
npm install react-hook-form
npm install zod
npm install @hookform/resolvers

npm install dotenv
```

```bash
# 명령어 모음 버전
npx expo install expo-secure-store expo-constants
npm install zustand axios react-hook-form zod @hookform/resolvers
```

```bash
# 네비게이션 (필요 시)
npm install @react-navigation/native @react-navigation/native-stack
npx expo install react-native-screens react-native-safe-area-context
```

<br />
<br />
<br />

3. 타입 정의

<br />

`src/types/auth.types.ts`

```ts
export interface User {
  id: string;
  email: string;
  name: string;
}

export interface AuthTokens {
  accessToken: string;
  refreshToken: string;
}

export interface LoginCredentials {
  email: string;
  password: string;
}

export interface AuthResponse {
  user: User;
  tokens: AuthTokens;
}**`src/types/api.types.ts`**

export interface ApiResponse<T = any> {
  success: boolean;
  data: T;
}

export enum ErrorCode {
  NETWORK_ERROR = 'NETWORK_ERROR',
  UNAUTHORIZED = 'UNAUTHORIZED',
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  SERVER_ERROR = 'SERVER_ERROR',
}

export class AppError extends Error {
  constructor(
    message: string,
    public code: ErrorCode,
    public statusCode?: number
  ) {
    super(message);
    this.name = 'AppError';
  }
}
```

<br />

`src/types/navigation.types.ts`

```ts
import { NativeStackScreenProps } from '@react-navigation/native-stack';

export type RootStackParamList = {
  Login: undefined;
  Home: undefined;
};

export type LoginScreenProps = NativeStackScreenProps<RootStackParamList, 'Login'>;
export type HomeScreenProps = NativeStackScreenProps<RootStackParamList, 'Home'>;

declare global {
  namespace ReactNavigation {
    interface RootParamList extends RootStackParamList {}
  }
}
```

<br />
<br />
<br />

4. 환경 설정

<br />

`src/config/env.ts`

```ts
import Constants from 'expo-constants';

const getApiUrl = (): string => {
  const apiUrl = Constants.expoConfig?.extra?.apiUrl;
  
  if (!apiUrl) {
    if (__DEV__) {
      console.warn('API_URL not configured, using localhost');
      return 'http://localhost:3000/api';
    }
    throw new Error('API_URL must be configured in production');
  }

  try {
    new URL(apiUrl);
    return apiUrl;
  } catch {
    throw new Error(`Invalid API_URL: ${apiUrl}`);
  }
};

export const ENV = {
  apiUrl: getApiUrl(),
  env: Constants.expoConfig?.extra?.env || 'development',
  isDev: __DEV__,
};
```

<br />

`.env`

```.env
API_URL=http://localhost:3000/api
NODE_ENV=development
```

<br />

`.env.development`

```.env
API_URL=http://localhost:3000/api
NODE_ENV=development
```

<br />

`.gitignore`

```.gitignore
# 기존 내용 유지하고 아래 추가
.env
.env.local
.env.*.local
```

<br />

`app.config.ts`

```ts
import 'dotenv/config';
import { ExpoConfig } from 'expo/config';

const config: ExpoConfig = {
  name: 'MyApp',
  slug: 'my-app',
  version: '1.0.0',
  extra: {
    apiUrl: process.env.API_URL || 'http://localhost:3000/api',
    env: process.env.NODE_ENV || 'development',
  },
};

export default config;
```

<br />
<br />
<br />

5. 유틸리티

<br />

`src/utils/storage.ts`

```ts
import * as SecureStore from 'expo-secure-store';

export const tokenStorage = {
  save: (token: string) => SecureStore.setItemAsync('refreshToken', token),
  get: () => SecureStore.getItemAsync('refreshToken'),
  remove: () => SecureStore.deleteItemAsync('refreshToken'),
};
```

<br />

`src/utils/error-handler.ts`

```ts
import axios from 'axios';
import { AppError, ErrorCode } from '../types/api.types';

export const handleApiError = (error: unknown): AppError => {
  if (axios.isAxiosError(error)) {
    const status = error.response?.status;
    const message = error.response?.data?.error?.message || error.message;

    if (status === 401) {
      return new AppError('인증이 필요합니다', ErrorCode.UNAUTHORIZED, 401);
    }
    if (status === 422) {
      return new AppError(message, ErrorCode.VALIDATION_ERROR, 422);
    }
    if (status && status >= 500) {
      return new AppError('서버 오류가 발생했습니다', ErrorCode.SERVER_ERROR, status);
    }
    if (error.code === 'ECONNABORTED') {
      return new AppError('네트워크 연결을 확인해주세요', ErrorCode.NETWORK_ERROR);
    }
  }

  if (error instanceof AppError) {
    return error;
  }

  return new AppError('예상치 못한 오류가 발생했습니다', ErrorCode.SERVER_ERROR);
};

export const getErrorMessage = (error: unknown): string => {
  if (error instanceof AppError) {
    return error.message;
  }
  return '예상치 못한 오류가 발생했습니다';
};
```

<br />
<br />
<br />

6. Store (Zustand)

<br />

`src/stores/authStore.ts`

```ts
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';
import { User } from '../types/auth.types';
import { tokenStorage } from '../utils/storage';

interface AuthStore {
  user: User | null;
  accessToken: string | null;
  isAuthenticated: boolean;
  isLoading: boolean;

  setUser: (user: User | null) => void;
  setToken: (token: string) => void;
  setLoading: (loading: boolean) => void;
  logout: () => Promise<void>;
}

export const useAuthStore = create<AuthStore>()(
  devtools(
    (set) => ({
      user: null,
      accessToken: null,
      isAuthenticated: false,
      isLoading: false,

      setUser: (user) => set({ user, isAuthenticated: !!user }),
      setToken: (token) => set({ accessToken: token, isAuthenticated: true }),
      setLoading: (loading) => set({ isLoading: loading }),

      logout: async () => {
        await tokenStorage.remove();
        set({ user: null, accessToken: null, isAuthenticated: false });
      },
    }),
    { name: 'AuthStore' }
  )
);
```

<br />
<br />
<br />

7. API 클라이언트

<br />

`src/services/api.ts`

```ts
import axios, { AxiosError, InternalAxiosRequestConfig } from 'axios';
import { ENV } from '../config/env';
import { useAuthStore } from '../stores/authStore';
import { tokenStorage } from '../utils/storage';

const api = axios.create({
  baseURL: ENV.apiUrl,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// ==========================================
// 요청 인터셉터: Access Token 자동 추가
// ==========================================
api.interceptors.request.use((config) => {
  const token = useAuthStore.getState().accessToken;
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// ==========================================
// 응답 인터셉터: 토큰 갱신 처리
// ==========================================
let isRefreshing = false;
let failedQueue: Array<{
  resolve: (token: string) => void;
  reject: (error: any) => void;
}> = [];

const processQueue = (error: any, token: string | null = null) => {
  failedQueue.forEach((promise) => {
    if (error) promise.reject(error);
    else if (token) promise.resolve(token);
  });
  failedQueue = [];
};

api.interceptors.response.use(
  (response) => response,
  async (error: AxiosError) => {
    const originalRequest = error.config as InternalAxiosRequestConfig & {
      _retry?: boolean;
    };

    // 원래 요청이 없거나 refresh API 자체의 에러면 종료
    if (!originalRequest || originalRequest.url?.includes('/auth/refresh')) {
      return Promise.reject(error);
    }

    // 401 에러이고 재시도하지 않은 경우
    if (error.response?.status === 401 && !originalRequest._retry) {
      // 이미 토큰 갱신 중이면 큐에 추가
      if (isRefreshing) {
        return new Promise((resolve, reject) => {
          failedQueue.push({ resolve, reject });
        }).then((token) => {
          originalRequest.headers.Authorization = `Bearer ${token}`;
          return api(originalRequest);
        });
      }

      originalRequest._retry = true;
      isRefreshing = true;

      try {
        const refreshToken = await tokenStorage.get();
        if (!refreshToken) {
          throw new Error('No refresh token');
        }

        // 별도의 axios 인스턴스로 refresh 요청 (인터셉터 우회)
        const { data } = await axios.post(
          `${ENV.apiUrl}/auth/refresh`,
          { refreshToken },
          { timeout: 10000 }
        );

        // 두 가지 응답 구조 모두 지원 (data.data 또는 data)
        const responseData = data.data || data;
        const { accessToken, refreshToken: newRefreshToken } = responseData;

        if (!accessToken || !newRefreshToken) {
          throw new Error('Invalid refresh response');
        }

        // 토큰 저장
        useAuthStore.getState().setToken(accessToken);
        await tokenStorage.save(newRefreshToken);

        // 대기 중인 요청들 처리
        processQueue(null, accessToken);

        // 원래 요청 재시도
        originalRequest.headers.Authorization = `Bearer ${accessToken}`;
        return api(originalRequest);
      } catch (err) {
        // 토큰 갱신 실패 시 로그아웃
        processQueue(err, null);
        await useAuthStore.getState().logout();
        return Promise.reject(err);
      } finally {
        isRefreshing = false;
      }
    }

    return Promise.reject(error);
  }
);

export default api;
```

<br />
<br />
<br />

8. 인증 서비스

<br />

`src/services/auth.service.ts`

```ts
import api from './api';
import { useAuthStore } from '../stores/authStore';
import { tokenStorage } from '../utils/storage';
import { handleApiError } from '../utils/error-handler';
import {
  LoginCredentials,
  AuthResponse,
  User,
} from '../types/auth.types';
import { ApiResponse } from '../types/api.types';

class AuthService {
  /**
   * 로그인
   */
  async login(credentials: LoginCredentials): Promise<User> {
    try {
      const response = await api.post<ApiResponse<AuthResponse>>(
        '/auth/login',
        credentials
      );

      const { user, tokens } = response.data.data;

      useAuthStore.getState().setToken(tokens.accessToken);
      useAuthStore.getState().setUser(user);
      await tokenStorage.save(tokens.refreshToken);

      return user;
    } catch (error) {
      throw handleApiError(error);
    }
  }

  /**
   * 로그아웃
   */
  async logout(): Promise<void> {
    try {
      await api.post('/auth/logout');
    } catch (error) {
      console.error('Logout API failed:', error);
    } finally {
      await useAuthStore.getState().logout();
    }
  }

  /**
   * 현재 사용자 정보 조회
   */
  async getMe(): Promise<User> {
    try {
      const response = await api.get<ApiResponse<User>>('/auth/me');
      const user = response.data.data;
      useAuthStore.getState().setUser(user);
      return user;
    } catch (error) {
      throw handleApiError(error);
    }
  }

  /**
   * 앱 초기화 (자동 로그인)
   */
  async initialize(): Promise<boolean> {
    try {
      const refreshToken = await tokenStorage.get();
      if (!refreshToken) {
        console.log('No refresh token found');
        return false;
      }

      const response = await api.post<
        ApiResponse<{ accessToken: string; refreshToken: string }>
      >('/auth/refresh', { refreshToken });

      // 두 가지 응답 구조 지원
      const responseData = response.data.data || response.data;
      const { accessToken, refreshToken: newRefreshToken } = responseData;

      useAuthStore.getState().setToken(accessToken);
      await tokenStorage.save(newRefreshToken);

      // 사용자 정보 조회 (실패해도 계속 진행)
      try {
        await this.getMe();
      } catch (error) {
        console.warn('Failed to fetch user info:', error);
      }

      return true;
    } catch (error) {
      console.error('Auth initialization failed:', error);
      await tokenStorage.remove();
      return false;
    }
  }
}

export const authService = new AuthService();
```

<br />
<br />
<br />

9. Zod 스키마

<br />

`src/schemas/auth.schema.ts`

```ts
import { z } from 'zod';

export const loginSchema = z.object({
  email: z
    .string()
    .min(1, '이메일을 입력해주세요')
    .email('올바른 이메일 형식이 아닙니다')
    .toLowerCase()
    .trim(),
  password: z
    .string()
    .min(1, '비밀번호를 입력해주세요')
    .min(6, '비밀번호는 최소 6자 이상'),
});

export const registerSchema = z
  .object({
    name: z.string().min(2, '이름은 최소 2자 이상').trim(),
    email: z.string().email('올바른 이메일 형식이 아닙니다').toLowerCase().trim(),
    password: z
      .string()
      .min(8, '비밀번호는 최소 8자 이상')
      .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, '대소문자와 숫자를 포함해야 합니다'),
    passwordConfirm: z.string(),
  })
  .refine((data) => data.password === data.passwordConfirm, {
    message: '비밀번호가 일치하지 않습니다',
    path: ['passwordConfirm'],
  });

export type LoginFormData = z.infer<typeof loginSchema>;
export type RegisterFormData = z.infer<typeof registerSchema>;
```

<br />
<br />
<br />

10. Custom Hook

<br />

`src/hooks/useAuth.ts`

```ts
import { useCallback } from 'react';
import { useAuthStore } from '../stores/authStore';
import { authService } from '../services/auth.service';
import { LoginCredentials, User } from '../types/auth.types';

export const useAuth = () => {
  // Selector로 최적화된 구독
  const user = useAuthStore((state) => state.user);
  const isAuthenticated = useAuthStore((state) => state.isAuthenticated);
  const isLoading = useAuthStore((state) => state.isLoading);

  const login = useCallback(async (credentials: LoginCredentials): Promise<User> => {
    useAuthStore.getState().setLoading(true);
    try {
      return await authService.login(credentials);
    } finally {
      useAuthStore.getState().setLoading(false);
    }
  }, []);

  const logout = useCallback(async (): Promise<void> => {
    useAuthStore.getState().setLoading(true);
    try {
      await authService.logout();
    } finally {
      useAuthStore.getState().setLoading(false);
    }
  }, []);

  return {
    user,
    isAuthenticated,
    isLoading,
    login,
    logout,
  };
};
```

<br />
<br />
<br />

11. 로그인 화면

<br />

`src/screens/LoginScreen.tsx`

```tsx
import React from 'react';
import { View, TextInput, TouchableOpacity, Text, Alert } from 'react-native';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { useAuth } from '../hooks/useAuth';
import { loginSchema, LoginFormData } from '../schemas/auth.schema';
import { getErrorMessage } from '../utils/error-handler';

export const LoginScreen = () => {
  const { login, isLoading } = useAuth();
  
  const {
    control,
    handleSubmit,
    formState: { errors },
  } = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
    defaultValues: { email: '', password: '' },
    mode: 'onBlur', // 포커스 벗어날 때 검증
  });

  const onSubmit = async (data: LoginFormData) => {
    try {
      await login(data);
    } catch (error) {
      Alert.alert('로그인 실패', getErrorMessage(error));
    }
  };

  return (
    <View style={{ flex: 1, justifyContent: 'center', padding: 20 }}>
      <Text
        style={{
          fontSize: 24,
          fontWeight: 'bold',
          marginBottom: 30,
          textAlign: 'center',
        }}
      >
        로그인
      </Text>

      {/* 이메일 입력 */}
      <Controller
        control={control}
        name="email"
        render={({ field: { onChange, onBlur, value } }) => (
          <TextInput
            style={{
              height: 50,
              borderWidth: 1,
              borderColor: errors.email ? '#f00' : '#ddd',
              borderRadius: 8,
              paddingHorizontal: 16,
              marginBottom: 5,
            }}
            placeholder="이메일"
            value={value}
            onChangeText={onChange}
            onBlur={onBlur}
            keyboardType="email-address"
            autoCapitalize="none"
            editable={!isLoading}
          />
        )}
      />
      {errors.email && (
        <Text style={{ color: '#f00', fontSize: 13, marginBottom: 15, marginLeft: 4 }}>
          {errors.email.message}
        </Text>
      )}

      {/* 비밀번호 입력 */}
      <Controller
        control={control}
        name="password"
        render={({ field: { onChange, onBlur, value } }) => (
          <TextInput
            style={{
              height: 50,
              borderWidth: 1,
              borderColor: errors.password ? '#f00' : '#ddd',
              borderRadius: 8,
              paddingHorizontal: 16,
              marginBottom: 5,
            }}
            placeholder="비밀번호"
            value={value}
            onChangeText={onChange}
            onBlur={onBlur}
            secureTextEntry
            autoCapitalize="none"
            editable={!isLoading}
          />
        )}
      />
      {errors.password && (
        <Text style={{ color: '#f00', fontSize: 13, marginBottom: 15, marginLeft: 4 }}>
          {errors.password.message}
        </Text>
      )}

      {/* 로그인 버튼 */}
      <TouchableOpacity
        style={{
          height: 50,
          backgroundColor: isLoading ? '#ccc' : '#007AFF',
          borderRadius: 8,
          justifyContent: 'center',
          alignItems: 'center',
          marginTop: 10,
        }}
        onPress={handleSubmit(onSubmit)}
        disabled={isLoading}
      >
        <Text style={{ color: '#fff', fontSize: 16, fontWeight: '600' }}>
          {isLoading ? '로그인 중...' : '로그인'}
        </Text>
      </TouchableOpacity>
    </View>
  );
};
```

<br />
<br />
<br />

12. 홈 화면

<br />

`src/screens/HomeScreen.tsx`

```tsx
import React from 'react';
import { View, Text, TouchableOpacity, Alert } from 'react-native';
import { useAuth } from '../hooks/useAuth';

export const HomeScreen = () => {
  const { user, logout, isLoading } = useAuth();

  const handleLogout = () => {
    Alert.alert('로그아웃', '로그아웃 하시겠습니까?', [
      { text: '취소', style: 'cancel' },
      {
        text: '로그아웃',
        style: 'destructive',
        onPress: logout,
      },
    ]);
  };

  return (
    <View style={{ flex: 1, padding: 20 }}>
      <Text
        style={{
          fontSize: 24,
          fontWeight: 'bold',
          marginBottom: 30,
          textAlign: 'center',
        }}
      >
        환영합니다!
      </Text>

      {user && (
        <View
          style={{
            backgroundColor: '#f5f5f5',
            padding: 20,
            borderRadius: 8,
            marginBottom: 20,
          }}
        >
          <Text style={{ fontSize: 14, color: '#666', marginBottom: 4 }}>이름</Text>
          <Text style={{ fontSize: 16, fontWeight: '500', marginBottom: 12 }}>
            {user.name}
          </Text>

          <Text style={{ fontSize: 14, color: '#666', marginBottom: 4 }}>이메일</Text>
          <Text style={{ fontSize: 16, fontWeight: '500' }}>{user.email}</Text>
        </View>
      )}

      <TouchableOpacity
        style={{
          height: 50,
          backgroundColor: isLoading ? '#ccc' : '#FF3B30',
          borderRadius: 8,
          justifyContent: 'center',
          alignItems: 'center',
        }}
        onPress={handleLogout}
        disabled={isLoading}
      >
        <Text style={{ color: '#fff', fontSize: 16, fontWeight: '600' }}>
          {isLoading ? '로그아웃 중...' : '로그아웃'}
        </Text>
      </TouchableOpacity>
    </View>
  );
};
```

<br />
<br />
<br />

13. App 설정

<br />

`App.tsx`

```tsx
import React, { useEffect, useState } from 'react';
import { View, ActivityIndicator } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { useAuthStore } from './src/stores/authStore';
import { authService } from './src/services/auth.service';
import { LoginScreen } from './src/screens/LoginScreen';
import { HomeScreen } from './src/screens/HomeScreen';
import { RootStackParamList } from './src/types/navigation.types';

const Stack = createNativeStackNavigator<RootStackParamList>();

export default function App() {
  const [isReady, setIsReady] = useState(false);
  const isAuthenticated = useAuthStore((state) => state.isAuthenticated);

  useEffect(() => {
    authService
      .initialize()
      .catch((error) => console.error('Initialization error:', error))
      .finally(() => setIsReady(true));
  }, []);

  if (!isReady) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <ActivityIndicator size="large" color="#007AFF" />
      </View>
    );
  }

  return (
    <NavigationContainer>
      <Stack.Navigator screenOptions={{ headerShown: false }}>
        {isAuthenticated ? (
          <Stack.Screen name="Home" component={HomeScreen} />
        ) : (
          <Stack.Screen name="Login" component={LoginScreen} />
        )}
      </Stack.Navigator>
    </NavigationContainer>
  );
}
```

<br />
<br />
<br />

14. 구현 정리

| 기능 | 구현 방식 |
|:---:|:---|
| **Access Token** | 메모리 저장 (Zustand) |
| **Refresh Token** | SecureStore 암호화 |
| **자동 갱신** | Axios 인터셉터 + 큐 관리 |
| **타입 안정성** | 100% TypeScript |
| **에러 처리** | 중앙화 + 사용자 친화적 |

<br />
<br />
<br />

15. 사용 방법

```bash
# 1. 설치
npm install

# 2. 환경 변수 설정 (.env)
API_URL=https://your-api.com/api
NODE_ENV=production

# 3. 실행
npx expo start
```
