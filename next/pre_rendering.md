# Pre-Rendering

<br />
<br />

* React 렌더링과 Next.js의 렌더링 차이
---

```
리액트는 기본적으로 CSR을 사용한다.

페이지 이동이 매우 빠르고 쾌적하다는 장점이 있으나,
FCP와 TTI가 전부 느리다는 단점이 있다.

Next.js에서는 어떻게 이 부분을 해결했는지 알아보자.

* FCP(First Contentful Paint) 요청이 시작되고 컨텐츠가 화면에 처음 나타나는데 걸리는 시간
* TTI(Time To Interactive) HTML의 모든 요소들이 상호작용 가능해진 시점
```

<br />
<br />
<br />
<br />

1. React

```
1) 유저 Request

2) 브라우저(Client)는 서버에 요청한다.

3) 서버는 index.html(빈 껍데기)를 브라우저에게 전달한다.

4) 브라우저는 빈 화면을 렌더링 (FCP) -> 유저는 빈 화면을 보고 있게 된다.

5) 서버가 JS Bundle (서비스에 접근 가능한 모든 컴포넌트 코드)을 후속으로 전달한다.

6) 브라우저는 JS Bundle을 실행한다. (리액트 앱)

7) 콘텐츠를 렌더링 후 유저에게 화면이 보이고 상호작용이 된다. (TTI)
```

<br />
<br />
<br />

2. Next (Pre-Rendering)

```
1) 유저 Request

2) 브라우저(Client)는 서버에 요청

3) Next 서버는 서버 내에서 JS를 실행 (렌더링)

4) 렌더링 된 HTML을 브라우저에 보냄 (상호 작용이 되는 건 아님) -> 사전 렌더링

5) 브라우저는 HTML 코드를 화면에 그려낸다. (FCP)

6) 서버가 JS Bundle (해당 페이지에 관련된 JS만)을 후속으로 전달한다.

7) 브라우저는 JS Bundle을 실행하여, HTML과 연결한다. (Hydration)

8) 화면의 상호작용 가능 (TTI)
```

<br />
<br />
<br />

3. 전체 렌더링 구조 정리

|유저|브라우저(클라이언트)|서버|
|:-:|:-:|:-:|
|접속 요청|------------------->|-------------------->|
|||JS 실행 (렌더링)|
|**FCP**|화면에 렌더링|<---- 렌더링 된 HTML|
||수화(Hydration)|<--------- JS Bundle|
|**TTI**|상호작용 가능||

<br />

```
조금만 더 추가하자면,
사전 렌더링 과정 중에 모든 컴포넌트를 렌더링해서
HTML 페이지를 생성하지만,
정확히는 서버 컴포넌트가 먼저 실행되고
그 이후에 클라이언트 컴포넌트가 실행된다.

이때 먼저 실행되는 서버 컴포넌트는
RSC (React Server Component) Payload라는 Json과 비슷한 문자열로 직렬화가 진행된다.

그렇기 때문에 서버 컴포넌트에서 클라이언트 컴포넌트로
전달되는 Props 중에 함수와 같은 객체가 있다면,
런타임 오류가 발생한다.
```
