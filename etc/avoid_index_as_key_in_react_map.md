# React의 map에서 인덱스를 Key로 사용하는 것을 피해야 한다.

<br />
<br />

* key prop이 React에서 하는 역할
---

```
React에서 key는 리스트를 렌더링할 때 각 항목을 구분하는 고유한 식별자 역할을 한다.

이게 왜 중요하냐면,
React는 리스트에 변화가 생겼을 때(항목이 추가되거나, 삭제되거나, 순서가 바뀌는 경우)
key를 보고 어떤 항목이 바뀌었는지 파악한다.

이를 통해 DOM을 변경된 부분만 효율적으로 업데이트하는 것이다.

즉, key는 React가 "이건 그대로 두고, 저건 바꿔야지"라고 판단하는 핵심적인 단서이다.
```

<br />
<br />
<br />
<br />

1. 인덱스를 key로 쓰면 왜 문제가 될까?

```
인덱스는 0, 1, 2처럼 순서대로 늘어나는 숫자라서 고유해 보이지만,
리스트가 동적으로 변할 때는 문제가 생긴다.

그 이유를 아래에서 자세히 살펴보자.
```

<br />

`1) 고유성이 깨질 수 있다.`

```
인덱스는 리스트에서 항목의 위치를 나타낼 뿐,
항목 자체의 고유한 특성을 반영하지 않는다.

예를 들어, 리스트의 순서가 바뀌거나 항목이 추가/삭제되면 인덱스가 바뀌어버린다.

React는 이걸 보고 "아, 이건 다른 항목이야"라고 오해할 수 있다.

인덱스는 데이터의 내용이 아니라 위치를 나타내기 때문이다.
```

<br />

```tsx
// 다음과 같은 리스트가 있다고 가정

const data = [
  { value: '항목 A' },
  { value: '항목 B' },
  { value: '항목 C' },
];

return (
  <ul>
    {data.map((item, index) => (
      <li key={index}>
        <input type="text" defaultValue={item.value} />
      </li>
    ))}
  </ul>
);
```

```html
<!-- 렌더링 결과 -->

<li key="0"><input value="항목 A" /></li>
<li key="1"><input value="항목 B" /></li>
<li key="2"><input value="항목 C" /></li>
```

<br />

```tsx
// 이제 사용자가 두 번째 입력 필드(항목 B)에 "안녕하세요"를 입력하고,
// 다음과 같이 업데이트되어 데이터 순서가 바뀌었다고 가정

const data = [
  { value: '항목 B' }, // 맨 위로 이동 (내용은 업데이트 되었다 치고)
  { value: '항목 A' },
  { value: '항목 C' },
];

```

```html
<!-- 렌더링 결과 -->

<li key="0"><input value="항목 B" /></li>
<li key="1"><input value="항목 A" /></li>
<li key="2"><input value="항목 C" /></li>
```

```
리액트는 key="1"인 요소가 이전에도 있었으므로, 그 요소를 재사용한다.

따라서 key="1"이었던 입력 필드(원래 "항목 B"에 연결된 필드)에 저장된
"안녕하세요" 값이 새로운 key="1"(이제 "항목 A")에 잘못 연결된다.

결과적으로

<input value="항목 B" />는 새로 렌더링되지만,
<input value="항목 A" />에 "안녕하세요"가 표시된다.

리액트는 key가 동일하면 "같은 요소"라고 생각하고,
상태(입력값 등)를 유지하려고 하기 때문이다.

하지만 인덱스는 데이터의 내용이 아니라 순서를 나타내기 때문에,
데이터 순서가 바뀌면 엉뚱한 요소에 상태가 연결된다.
```

<br />
<br />

`2) 불필요한 업데이트로 성능 저하`

```
React는 key를 기준으로 항목을 비교하는데,
인덱스를 쓰면 리스트가 바뀌었을 때 React가 제대로 감지하지 못한다.

그러면 실제로 바뀌지 않은 항목까지 새로 렌더링하게 되어 성능이 떨어질 수 있다.
```

<br />

`3) 상태 유지 문제`

```
만약 리스트 항목에 입력값이나 체크박스 같은 상태가 연결되어 있다면,
인덱스를 key로 쓰면 항목 순서가 바뀌었을 때 상태가 엉뚱한 항목에 붙어버릴 수 있다.

사용자가 혼란스러워질 수 있는 상황이 발생하는 것.
```

<br />
<br />
<br />

2. 코드로 보는 예시

```
이론만 보면 좀 추상적일 수 있으니,
간단한 예시로 확인해보자.
```

<br />

`1) 예시`

```tsx
const items = ['사과', '바나나', '체리'];

const List = () => (
  <ul>
    {items.map((item, index) => (
      <li key={index}>{item}</li>
    ))}
  </ul>
);
```

```
초기 상태: ['사과', '바나나', '체리']
key=0: 사과, key=1: 바나나, key=2: 체리
```

```
변경 후: ['바나나', '사과', '체리'] (순서만 바뀜)
key=0: 바나나, key=1: 사과, key=2: 체리
```

```
React 입장에서는 key=0이 '사과'에서 '바나나'로, key=1이 '바나나'에서 '사과'로 바뀐 걸로 보인다.

그래서 실제로는 순서만 바뀐 건데,
모든 항목이 변경된 것처럼 인식하고 DOM을 다시 그릴 가능성이 크다.

만약 key로 고유한 값을 썼다면(예: 데이터의 ID),
순서가 바뀌어도 React가 "아, 이건 같은 항목이구나" 하고 필요한 부분만 업데이트했을 것이다.
```

<br />

`2) 예시`

```tsx
import { useState } from 'react';

function List() {
  const [items, setItems] = useState(['사과', '바나나', '체리']);

  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
}

export default List;
```

```
// 초기 렌더링 결과

<li key="0">사과</li>
<li key="1">바나나</li>
<li key="2">체리</li>
```

```
여기서 key는,
인덱스(0, 1, 2)로 설정되어 있다.
```

<br />

```
// 이제 리스트 맨 앞에 "오렌지"를 추가한다고 해보자.

setItems(['오렌지', '사과', '바나나', '체리']);
```

```
// 변경 후 렌더링 결과

<li key="0">오렌지</li>
<li key="1">사과</li>
<li key="2">바나나</li>
<li key="3">체리</li>
```

```
원래 key="0"은 "사과"였는데, 이제 "오렌지"가 됐다.

원래 key="1"은 "바나나"였는데, 이제 "사과"가 됐다.

React 입장에서는 key="0"이 바뀌었다고 생각해서 "사과"가 "오렌지"로 변한 걸로 오해할 수 있다.

실제로는 "오렌지"가 새로 추가된 거지만,
인덱스 기반 key 때문에 React가 결과적으로 불필요하게 DOM을 다시 그리거나 상태가 엉킬 수 있다.
```

<br />
<br />
<br />

3. 그럼 key는 어떻게 써야 할까?

`고유하고 안정적인 값 사용`

```
리스트 항목마다 변하지 않는,
고유한 값(예: 데이터베이스의 ID나 UUID)을 key로 쓰는 게 가장 좋다.
```
